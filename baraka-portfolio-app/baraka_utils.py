# -*- coding: utf-8 -*-
"""baraka_utilsipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t2I_r0FcmQ0B8HTqMBiJVpTE4wfmSH4U
"""

import numpy as np
import pandas as pd
import yfinance as yf
from scipy.optimize import minimize

SECTOR_GROUPS = {
    'Tech_US': ['AAPL', 'MSFT', 'GOOGL', 'NVDA'],
    'Finance_US': ['JPM', 'GS', 'BAC'],
    'Healthcare_US': ['JNJ', 'PFE', 'UNH'],
    'Consumer_US': ['PG', 'KO', 'PEP'],
    'Crypto': ['BTC-USD', 'ETH-USD', 'SOL-USD']
}

def get_data(tickers, start='2020-01-01', end='2024-01-01'):
    data = yf.download(tickers, start=start, end=end, auto_adjust=True)['Close']
    if isinstance(data, pd.Series):
        data = data.to_frame()
    returns = data.pct_change().dropna()
    return returns, data

def compute_portfolio_performance(weights, returns):
    portfolio_return = np.dot(weights, returns.mean()) * 252
    portfolio_volatility = np.sqrt(np.dot(weights.T, np.dot(returns.cov() * 252, weights)))
    sharpe_ratio = (portfolio_return - 0.02) / portfolio_volatility
    return portfolio_return, portfolio_volatility, sharpe_ratio

def compute_drawdown(cumulative_returns):
    peak = cumulative_returns.cummax()
    drawdown = (cumulative_returns - peak) / peak
    return drawdown.min()

def michaud_resampling(expected_returns, cov_matrix, n_simulations=500):
    n_assets = len(expected_returns)
    weights_list = []

    for _ in range(n_simulations):
        simulated_returns = expected_returns + np.random.normal(0, 0.02, size=n_assets)

        def objective(weights):
            return np.sqrt(weights.T @ cov_matrix @ weights)

        constraints = ({'type': 'eq', 'fun': lambda x: np.sum(x) - 1})
        bounds = tuple((0, 1) for _ in range(n_assets))
        init_guess = np.repeat(1/n_assets, n_assets)

        result = minimize(objective, init_guess, method='SLSQP', bounds=bounds, constraints=constraints)

        if result.success:
            weights_list.append(result.x)

    return np.mean(weights_list, axis=0)

def get_fundamentals(tickers):
    fundamentals = []
    for ticker in tickers:
        info = yf.Ticker(ticker).info
        fundamentals.append({
            'Ticker': ticker,
            'P/E Ratio': info.get('trailingPE', None),
            'Dividend Yield': info.get('dividendYield', None),
            'ROE': info.get('returnOnEquity', None),
            'Debt/Equity': info.get('debtToEquity', None)
        })
    return pd.DataFrame(fundamentals)

def score_factors(df, price_data):
    df['Value'] = 1 / df['P/E Ratio']
    df['Quality'] = df['ROE']
    momentum_scores = []
    for ticker in df['Ticker']:
        if ticker in price_data.columns:
            recent = price_data[ticker].iloc[-1]
            past_6m = price_data[ticker].iloc[-126] if len(price_data[ticker]) >= 126 else np.nan
            momentum = (recent / past_6m - 1) if pd.notnull(past_6m) else np.nan
        else:
            momentum = np.nan
        momentum_scores.append(momentum)
    df['Momentum'] = momentum_scores
    return df